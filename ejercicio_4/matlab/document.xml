<?xml version="1.0" encoding="UTF-8"?><w:document xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"><w:body><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Ejercicio 4. </w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>Desarrollar un programa en Matlab/Octave que permita </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>detectar códigos de barras</w:t></w:r><w:r><w:t> utilizando rutinas básicas de procesamiento de imagen. Para probar el algoritmo se proporciona un pequeño conjunto de imágenes junto con el enunciado (sección de recursos de moodle). Igualmente, el alumno podrá capturar sus propias imágenes y comprobar la efectividad del método desarrollado. Los pasos a seguir para tratar de detectar un código de barras se detallan a continuación: </w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>1. </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>Reducir la resolución</w:t></w:r><w:r><w:t> de la imagen a una cuarta parte. No necesitamos imágenes de 8M (como las del dataset) para detectar códigos de barras. </w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[clear all
A = imread("barcode3.jpg"); % 2448x3164
B = imresize(A, 0.25); % 612x816]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>2. </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>Convertir la imagen a escala de grises </w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[I = rgb2gray(B);
imshow(I)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>3. </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>Calcular la magnitud del gradiente</w:t></w:r><w:r><w:t> para la imagen en escala de grises. </w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>    ○ Usar el operador Scharr para calcular el gradiente en la dirección x e y </w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>    ○ El resultado serán dos imágenes (gradientX, gradientY). Una con el gradiente para la dirección x y otra con el gradiente para la direccion y. </w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>    ○ Calcular la diferencia en valor absoluto de ambas imágenes (gradientX-gradientY) </w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[%python code: 
%def from_gradient(gray):
%        fieldx = cv2.Scharr(gray, cv2.CV_32F, 1, 0) / 15.36
%        fieldy = cv2.Scharr(gray, cv2.CV_32F, 0, 1) / 15.36
%
%        return VectorField(fieldx, fieldy) 

[gradientX,gradientY] = imgradientxy(I);
imshow(gradientX)
imshow(gradientY)
diff = abs(gradientX-gradientY);
imshow(diff)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>4. Para eliminar ruido en la imagen de gradiente resultante, aplicar un </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>filtro media</w:t></w:r><w:r><w:t> ( tamaño de kernel 9x9 por ejemplo) </w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[J = medfilt2(diff,[9 9]);
imshow(J)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>5. A continuación, </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>umbralizar el fotograma</w:t></w:r><w:r><w:t> resultante. Buscamos mantener la atención únicamente en aquellas zonas con un gradiente elevado. Todo valor de gradiente por debajo de 200 tomará valor cero. Todo valor por encima de 200 tomará valor 1. </w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[%T = 255/200; % valor entre [0 1]
%BW = imbinarize(J,T);
BW = J > 200;
imshow(BW)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>6. Aplicar una </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>operación de cierre</w:t></w:r><w:r><w:t> morfológico (imclose) utilizando un elemento estructurante de 21x7. El objetivo es eliminar las separaciones existentes entre las barras y simplificar así la tarea de extraer el contorno del código de barras.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[SE = strel('rectangle',[7 21]);
BW = imclose(BW,SE);
imshow(BW)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>7. Aplicar </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>cuatro operaciones de erosión y cuatro de dilatación</w:t></w:r><w:r><w:t> empleando un elemento estructurante cuadrado de 3x3. El objetivo es eliminar pequeños blobs en la imagen. </w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[SE2 = strel('square', 3);
for i=1:4
    BW = imerode(BW,SE2);
end
for j=1:4
    BW = imdilate(BW,SE2);
end
imshow(BW)]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="text"/><w:jc w:val="left"/></w:pPr><w:r><w:t>8. </w:t></w:r><w:r><w:rPr><w:b/></w:rPr><w:t>Calcular los contornos</w:t></w:r><w:r><w:t> en la imagen resultante tras aplicar las operaciones morfológicas. Seleccionar aquel de mayor tamaño y dibujar el bounding box que lo contiene en la imagen original. El programa desarrollado deberá presentar al menos una función llamada barCodeDetector que reciba como argumento una imagen de entrada y presente en pantalla el resultado de la detección.</w:t></w:r></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[%contours = imcontour(BW);
%imshow(contours)
st = regionprops(BW, 'BoundingBox', 'Area' );
[maxArea, indexOfMax] = max([st.Area]);
imshow(B)
rectangle('Position',[st(indexOfMax).BoundingBox(1),st(indexOfMax).BoundingBox(2),st(indexOfMax).BoundingBox(3),st(indexOfMax).BoundingBox(4)], 'EdgeColor','r','LineWidth',3 )]]></w:t></w:r></w:p><w:p><w:pPr><w:sectPr/></w:pPr></w:p><w:p><w:pPr><w:pStyle w:val="code"/></w:pPr><w:r><w:t><![CDATA[% Testing
A1 = imread("barcode1.jpg");
A2 = imread("barcode2.jpg");
A3 = imread("barcode3.jpg");
A4 = imread("barcode4.jpg");
A5 = imread("barcode5.jpg");
A6 = imread("barcode6.jpg");
barCodeDetector(A1)
barCodeDetector(A2)
barCodeDetector(A3)
barCodeDetector(A4)
barCodeDetector(A5)
barCodeDetector(A6)]]></w:t></w:r></w:p></w:body></w:document>